/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/assets/sprites/enemy1.png":
/*!***************************************!*\
  !*** ./src/assets/sprites/enemy1.png ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"07854054d7e745df64b3.png\";\n\n//# sourceURL=webpack://plants_vs_zombies_clone/./src/assets/sprites/enemy1.png?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _assets_sprites_enemy1_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assets/sprites/enemy1.png */ \"./src/assets/sprites/enemy1.png\");\n\r\n\r\nconst canvas = document.querySelector('#canvas');\r\ncanvas.width = 600;\r\ncanvas.height = 400;\r\nconst ctx = canvas.getContext('2d');\r\n\r\nconst cellSize = 50;\r\nlet mouseX = undefined;\r\nlet mouseY = undefined;\r\nlet cells = [];\r\nlet projectiles = [];\r\nconst numOfRows = 7;\r\nlet enemies = [];\r\nlet ressources = 300;\r\n// health of the base. If it falls below 0 the game is lost\r\nlet baseHealth = 500;\r\n// victory points are awarded when an enemy is killed. If enough are reached, the player wins\r\nlet victoryPoints = 0;\r\nlet gameIsRunning = false;\r\n\r\nclass Enemy {\r\n  constructor(y) {\r\n    this.health = 100;\r\n    this.worth = 50;\r\n    this.damage = 20;\r\n    this.y = y;\r\n    this.x = canvas.width;\r\n    this.width = cellSize;\r\n    this.height = cellSize;\r\n    this.speed = 0.5;\r\n    this.isMoving = true;\r\n    this.row = y / cellSize;\r\n    this.victoryPoints = 5;\r\n    this.spriteSheet = new Image();\r\n    this.spriteSheet.src = _assets_sprites_enemy1_png__WEBPACK_IMPORTED_MODULE_0__;\r\n    this.frameX = 0;\r\n    this.frameY = 25; // set start frame to the first frame of the walking animation\r\n    this.frameWidth = 258;\r\n    this.frameHeight = 258;\r\n    // first 15 animations have different height - account for that\r\n    this.frameOffset = 2910;\r\n\r\n    // \"metadata\" about the spritesheet. Since it will be different for every spritesheet, we have to connect it somehow\r\n    // to a specific spritesheet. Maybe save it a json and load it together with the corresponding spritesheet?\r\n    this.spriteSheetInfo = {\r\n      width: 258,\r\n      height: 6780,\r\n      animationSets: {\r\n        move: {\r\n          numOfSprites: 5,\r\n          currentSprite: 99, // set a number greater the numOfSprites so that on the first run, we reset it to 0\r\n          startX: 0,\r\n          startY: 5490,\r\n          sizeX: 258,\r\n          sizeY: 258\r\n        }\r\n      }\r\n    };\r\n\r\n    this.animation = null;\r\n  }\r\n\r\n  draw() {\r\n    this.animation = this.spriteSheetInfo.animationSets.move;\r\n    // debounce animation\r\n    if (frames % 10 === 0) {\r\n      // walking animation starts at sprite 25 and ends at sprite 29\r\n      if (this.frameY >= 29) {\r\n        this.frameY = 25;\r\n      } else {\r\n        this.frameY++;\r\n      }\r\n      // new try with animation variable\r\n      // we increment the sprite first and the check if it exceeds the limit. Keep in mind, it is 5 sprites here, but we\r\n      // start at 0! So we actually have indices 0-4. If the index reaches 5, we must reset it to 0.\r\n      // Another option is to keep the if-else structure, but then we need to move this code below the drawImage function!\r\n      // Otherwise this happens: we come in with index 4, which still triggers the else part of the statement. So we increment\r\n      // it to 5 and draw index 5 which is actually too big.\r\n      // We could also subtract -1 from numOfSprites in the if-statement to account for starting at 0. maybe this would be\r\n      // most reasonable.\r\n      this.animation.currentSprite++;\r\n      if (this.animation.currentSprite >= this.animation.numOfSprites) {\r\n        this.animation.currentSprite = 0;\r\n      } else {\r\n        //this.animation.currentSprite++;\r\n      }\r\n      //console.log(this.animation.currentSprite);\r\n    }\r\n\r\n    if (this.isMoving) {\r\n      this.x -= this.speed;\r\n    }\r\n\r\n    //ctx.fillStyle = '#F00';\r\n    //ctx.fillRect(this.x, this.y, cellSize, cellSize);\r\n    /*ctx.drawImage(\r\n      this.spriteSheet,\r\n      this.frameX,\r\n      (this.frameY - 15) * this.frameHeight + this.frameOffset,\r\n      this.frameWidth,\r\n      this.frameHeight,\r\n      this.x,\r\n      this.y,\r\n      this.width,\r\n      this.height\r\n    );*/\r\n    ctx.drawImage(\r\n      this.spriteSheet,\r\n      this.animation.startX,\r\n      this.animation.startY +\r\n        this.animation.currentSprite * this.animation.sizeY,\r\n      this.animation.sizeX,\r\n      this.animation.sizeY,\r\n      this.x,\r\n      this.y,\r\n      this.width,\r\n      this.height\r\n    );\r\n    // draw health info\r\n    ctx.fillStyle = '#000';\r\n    ctx.font = '16px Arial';\r\n    ctx.fillText(this.health, this.x + 10, this.y + 20);\r\n  }\r\n}\r\n\r\nlet once = false; // we used once variable to spawn only one enemy to debug animation\r\nfunction generateEnemies() {\r\n  // we add cellsize to account for the uppermost part of the\r\n  // canvas that is not part of the gamebord\r\n  let randomRow = Math.floor(Math.random() * numOfRows) * cellSize + cellSize;\r\n  if (frames % 150 === 0 && once === false) {\r\n    enemies.push(new Enemy(randomRow));\r\n    //once = true;\r\n  }\r\n}\r\n\r\nfunction drawEnemies() {\r\n  enemies.forEach(enemy => {\r\n    enemy.draw();\r\n  });\r\n}\r\n\r\nfunction handleEnemies() {\r\n  // if an enemy leaves the board, damage the base and\r\n  // remove him from the enemies array\r\n  for (let i = 0; i < enemies.length; i++) {\r\n    enemies[i].isMoving = true;\r\n    // remove dead enemies and grant ressources\r\n    if (enemies[i].health <= 0) {\r\n      ressources += enemies[i].worth;\r\n      victoryPoints += enemies[i].victoryPoints;\r\n      enemies.splice(i, 1);\r\n      i--;\r\n      continue;\r\n    }\r\n\r\n    if (enemies[i].x < 0 - cellSize) {\r\n      // damage the base\r\n      baseHealth -= enemies[i].damage;\r\n      // remove enemy from the array\r\n      enemies.splice(i, 1);\r\n      // decrement i because array gets shorter\r\n      // in practice this should be nigh irrelevant because though\r\n      // it prevents \"jumping\" over the next array element, both\r\n      // elements would need to be outside the gameboard on the\r\n      // exact same frame\r\n      i--;\r\n    }\r\n  }\r\n}\r\n\r\nclass Projectile {\r\n  constructor(x, y, damage) {\r\n    this.damage = damage;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = 20;\r\n    this.height = 20;\r\n    this.row = y / cellSize;\r\n    this.speed = 0.5;\r\n  }\r\n\r\n  draw() {\r\n    this.x += this.speed;\r\n    ctx.fillStyle = '#FF0';\r\n    ctx.fillRect(\r\n      this.x + this.width / 2,\r\n      this.y + this.height / 2,\r\n      this.width,\r\n      this.height\r\n    );\r\n  }\r\n}\r\n\r\nclass Defender {\r\n  static cost = 100;\r\n\r\n  constructor(x, y, width, height) {\r\n    this.health = 100;\r\n    this.damage = 20;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.row = y / cellSize;\r\n  }\r\n\r\n  draw() {\r\n    ctx.fillStyle = '#00F';\r\n    ctx.fillRect(this.x, this.y, this.width, this.height);\r\n    // draw health info\r\n    ctx.fillStyle = '#000';\r\n    ctx.font = '16px Arial';\r\n    ctx.fillText(this.health, this.x + 10, this.y + 30);\r\n  }\r\n\r\n  shoot() {\r\n    if (detectEnemiesOnRow(this.row)) {\r\n      projectiles.push(new Projectile(this.x, this.y, this.damage));\r\n    }\r\n  }\r\n}\r\n\r\nclass Cell {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = cellSize;\r\n    this.height = cellSize;\r\n    this.defender = null;\r\n    this.row = y / cellSize;\r\n  }\r\n\r\n  isHoverdOver(x, y) {\r\n    return (\r\n      this.x < x &&\r\n      this.x + this.width > x &&\r\n      this.y < y &&\r\n      this.y + this.height > y\r\n    );\r\n  }\r\n}\r\n\r\n// create the cell objects\r\nfunction createCells() {\r\n  for (let x = 0; x < canvas.width; x += cellSize) {\r\n    for (let y = cellSize; y < canvas.height; y += cellSize) {\r\n      let cell = new Cell(x, y);\r\n      cells.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\n// TODO: naming of the function is not good. It actually defines mouse position, not highlighting it!\r\nfunction highlightMouseCell(e) {\r\n  // only perform this action every 2 frames (primitive debounce).\r\n  if (frames % 2 === 0) {\r\n    // console.log(e);\r\n    // console.log(canvas);\r\n\r\n    // if the mouse is not inside the canvas, return\r\n    if (\r\n      e.clientX - canvas.offsetLeft < 0 || // left\r\n      e.clientX - canvas.offsetLeft > canvas.width || // right\r\n      e.clientY - canvas.offsetTop < 0 || // top\r\n      e.clientY - canvas.offsetTop > canvas.height // bottom\r\n    ) {\r\n      mouseX = undefined;\r\n      mouseY = undefined;\r\n      return;\r\n    }\r\n    mouseX = e.clientX - canvas.offsetLeft;\r\n    mouseY = e.clientY - canvas.offsetTop;\r\n\r\n    // console.log('mouseX: ' + mouseX);\r\n    // console.log('mouseY: ' + mouseY);\r\n  }\r\n}\r\n\r\n// TODO: we can simply loop over the cells array - no need for nested for-loop!\r\nfunction drawGrid() {\r\n  ctx.strokeStyle = '#000';\r\n  for (let x = 0; x < canvas.width; x += cellSize) {\r\n    for (let y = cellSize; y < canvas.height; y += cellSize) {\r\n      // highlight the cell with the cursor\r\n      if (\r\n        mouseX &&\r\n        mouseX > x &&\r\n        mouseX < x + cellSize &&\r\n        mouseY &&\r\n        mouseY > y &&\r\n        mouseY < y + cellSize\r\n      ) {\r\n        ctx.strokeStyle = '#0F0';\r\n        ctx.beginPath();\r\n        ctx.rect(x, y, cellSize, cellSize);\r\n        ctx.stroke();\r\n        ctx.strokeStyle = '#000';\r\n      }\r\n      // we can use this later if we want to toggle grid on/off\r\n      else {\r\n        ctx.beginPath();\r\n        ctx.rect(x, y, cellSize, cellSize);\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// actually, we could check when the cells are drawn if the cell has a defender and then handle him.\r\nfunction drawDefenders() {\r\n  let cellsWithDefenders = cells.filter(cell => cell.defender !== null);\r\n  cellsWithDefenders.forEach(cell => {\r\n    // if defender health is 0 or below, remove him\r\n    if (cell.defender.health <= 0) {\r\n      cell.defender = null;\r\n      return;\r\n    }\r\n    cell.defender.draw();\r\n    if (frames % 150 == 0) cell.defender.shoot();\r\n  });\r\n}\r\n\r\nfunction handleProjectiles() {\r\n  for (let i = 0; i < projectiles.length; i++) {\r\n    projectiles[i].draw();\r\n\r\n    // if the projectile goes off screen, remove it\r\n    if (projectiles[i].x > canvas.width) {\r\n      projectiles.splice(i, 1);\r\n      i--;\r\n      continue;\r\n    }\r\n\r\n    // we use every here, because we cannot break out of forEach once we found a collision\r\n    enemies.every(enemy => {\r\n      if (\r\n        projectiles[i].x + projectiles[i].width >= enemy.x &&\r\n        projectiles[i].row === enemy.row\r\n      ) {\r\n        enemy.health -= projectiles[i].damage;\r\n        projectiles.splice(i, 1);\r\n        i--;\r\n        // return false to break out of every\r\n        return false;\r\n      }\r\n      // return true to keep the loop going\r\n      return true;\r\n    });\r\n  }\r\n}\r\n\r\nfunction placeDefender(e) {\r\n  if (!gameIsRunning) {\r\n    return;\r\n  }\r\n\r\n  let activeCellArr = cells.filter(cell => cell.isHoverdOver(mouseX, mouseY));\r\n  if (activeCellArr.length !== 1) return;\r\n\r\n  let activeCell = activeCellArr[0];\r\n\r\n  if (activeCell.defender) {\r\n    console.log('there is already a defender on this tile');\r\n    return;\r\n  }\r\n\r\n  // check if we can afford the defender\r\n  if (ressources - Defender.cost < 0) {\r\n    console.log('not enough ressources');\r\n    return;\r\n  }\r\n\r\n  // make sure that there is no enemy on the tile\r\n  let enemyAtTheGates = enemies.filter(enemy => {\r\n    return detectRowBasedCollision(activeCell, enemy);\r\n  });\r\n  if (enemyAtTheGates.length > 0) {\r\n    console.log('you cannot place defenders on tiles with enemies!');\r\n    return;\r\n  }\r\n\r\n  activeCell.defender = new Defender(\r\n    activeCell.x,\r\n    activeCell.y,\r\n    activeCell.width,\r\n    activeCell.height\r\n  );\r\n  ressources -= Defender.cost;\r\n\r\n  console.log(activeCell);\r\n}\r\n\r\n/** Helper that returns an array of defender objects. */\r\nfunction getDefendersArray() {\r\n  return cells.reduce(function(defendersArr, cell) {\r\n    if (cell.defender !== null) {\r\n      defendersArr.push(cell.defender);\r\n    }\r\n    return defendersArr;\r\n  }, []);\r\n}\r\n\r\n/** Helper that detects if there are enemies on the defender's row */\r\nfunction detectEnemiesOnRow(row) {\r\n  return enemies.some(enemy => enemy.row === row);\r\n}\r\n\r\n// this function draws all the info about game state\r\nfunction drawGameInfo() {\r\n  ctx.fillStyle = '#000';\r\n  ctx.font = '20px Arial';\r\n  ctx.fillText('Ressources: ' + ressources, 10, 30);\r\n  ctx.fillText('Health of base: ' + baseHealth, 200, 30);\r\n  ctx.fillText('Victory Points: ' + victoryPoints, 420, 30);\r\n}\r\n\r\n// handle collision detection between defenders and enemies\r\nfunction detectRowBasedCollision(defender, enemy) {\r\n  return (\r\n    defender.x + defender.width >= enemy.x &&\r\n    // without this condition, it would not be able to place\r\n    // defenders to the right of enemies\r\n    defender.x < enemy.x + enemy.width &&\r\n    defender.row === enemy.row\r\n  );\r\n}\r\n\r\nfunction handleCollisions() {\r\n  let defenders = getDefendersArray();\r\n\r\n  if (defenders.length >= 1) {\r\n    defenders.forEach(defender => {\r\n      enemies.forEach(enemy => {\r\n        if (detectRowBasedCollision(defender, enemy)) {\r\n          // stop the enemy from moving\r\n          enemy.isMoving = false;\r\n          // reduce the health of the defender\r\n          // (debounce it a bit because it is very fast)\r\n          if (frames % 5 === 0) defender.health -= 1;\r\n          // if the defender is dead, start moving again.\r\n          // defenders are removed in drawDefenders function\r\n          if (defender.health <= 0) enemy.isMoving = true;\r\n        }\r\n      });\r\n    });\r\n  } else {\r\n    // if there are no defenders, make sure all enemies are moving\r\n    enemies.forEach(enemy => (enemy.isMoving = true));\r\n  }\r\n}\r\n\r\nfunction restartGame(e) {\r\n  // check if we clicked on the button\r\n  if (\r\n    !gameIsRunning &&\r\n    e.clientX >= canvas.width / 2 - 60 &&\r\n    e.clientX <= canvas.width / 2 + 60 &&\r\n    e.clientY >= canvas.height / 2 + 80 &&\r\n    e.clientY <= canvas.height / 2 + 120\r\n  ) {\r\n    gameIsRunning = true;\r\n    // reset the ctx text properties to their default\r\n    ctx.textBaseline = 'alphabetic';\r\n    ctx.textAlign = 'start';\r\n    // reset game variables\r\n    frames = 0;\r\n    enemies = [];\r\n    ressources = 300;\r\n    baseHealth = 500;\r\n    victoryPoints = 0;\r\n    cells = [];\r\n    projectiles = [];\r\n    gameLoop();\r\n    createCells();\r\n  }\r\n}\r\n\r\nlet frames = 0;\r\n\r\nfunction gameLoop() {\r\n  // check if game is won or lost\r\n  if (baseHealth <= 0) {\r\n    gameIsRunning = false;\r\n    ctx.fillStyle = 'rgba(0,0,0,.5)';\r\n    ctx.fillRect(0, 0, 600, 400);\r\n    ctx.fillStyle = '#FFF';\r\n    ctx.font = '30px Arial';\r\n    // center the text\r\n    ctx.textBaseline = 'middle';\r\n    ctx.textAlign = 'center';\r\n\r\n    ctx.fillText(\r\n      'The enemies destroyed the base.',\r\n      canvas.width / 2,\r\n      canvas.height / 2 + 20\r\n    );\r\n    ctx.fillText('The game is lost!', canvas.width / 2, canvas.height / 2 - 20);\r\n    // draw restart button\r\n    ctx.fillStyle = '#FFF';\r\n    ctx.fillRect(canvas.width / 2 - 60, canvas.height / 2 + 80, 120, 40);\r\n    ctx.fillStyle = '#000';\r\n    ctx.font = '20px Arial';\r\n    ctx.fillText('PLAY AGAIN', canvas.width / 2, canvas.height / 2 + 100);\r\n    return;\r\n  } else if (victoryPoints >= 100) {\r\n    gameIsRunning = false;\r\n    ctx.fillStyle = 'rgba(0,0,0,.5)';\r\n    ctx.fillRect(0, 0, 600, 400);\r\n    ctx.fillStyle = '#FFF';\r\n    ctx.font = '30px Arial';\r\n    ctx.textBaseline = 'middle';\r\n    ctx.textAlign = 'center';\r\n    ctx.fillText(\r\n      'The enemy forces suffered heavy losses',\r\n      canvas.width / 2,\r\n      canvas.height / 2 - 40\r\n    );\r\n    ctx.fillText('and are retreating.', canvas.width / 2, canvas.height / 2);\r\n    ctx.fillText(\r\n      'You are victorious!',\r\n      canvas.width / 2,\r\n      canvas.height / 2 + 40\r\n    );\r\n    // draw restart button\r\n    ctx.fillStyle = '#FFF';\r\n    ctx.fillRect(canvas.width / 2 - 60, canvas.height / 2 + 80, 120, 40);\r\n    ctx.fillStyle = '#000';\r\n    ctx.font = '20px Arial';\r\n    ctx.fillText('PLAY AGAIN', canvas.width / 2, canvas.height / 2 + 100);\r\n\r\n    return;\r\n  }\r\n\r\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n  drawGrid();\r\n  drawDefenders();\r\n  handleProjectiles();\r\n\r\n  generateEnemies();\r\n  handleEnemies();\r\n  handleCollisions();\r\n  drawEnemies();\r\n  drawGameInfo();\r\n\r\n  frames++;\r\n\r\n  requestAnimationFrame(gameLoop);\r\n}\r\n\r\n//gameLoop();\r\n// create the cells once.\r\n//createCells();\r\n\r\n// draw the start screen\r\nctx.fillStyle = 'rgba(0,0,0,.5)';\r\nctx.fillRect(0, 0, 600, 400);\r\nctx.fillStyle = '#FFF';\r\nctx.font = '30px Arial';\r\nctx.textBaseline = 'middle';\r\nctx.textAlign = 'center';\r\nctx.fillText(\r\n  'Enemies are attacking our base!',\r\n  canvas.width / 2,\r\n  canvas.height / 2 - 40\r\n);\r\nctx.font = '20px Arial';\r\nctx.fillText(\r\n  'Place defenders with the mouse to defend the base.',\r\n  canvas.width / 2,\r\n  canvas.height / 2\r\n);\r\n// draw restart button\r\nctx.fillStyle = '#FFF';\r\nctx.fillRect(canvas.width / 2 - 60, canvas.height / 2 + 80, 120, 40);\r\nctx.fillStyle = '#000';\r\nctx.font = '20px Arial';\r\nctx.fillText('START', canvas.width / 2, canvas.height / 2 + 100);\r\n\r\ndocument.addEventListener('mousemove', highlightMouseCell);\r\ndocument.addEventListener('click', placeDefender);\r\ndocument.addEventListener('click', restartGame);\r\n\n\n//# sourceURL=webpack://plants_vs_zombies_clone/./src/game.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/game.js");
/******/ 	
/******/ })()
;