/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/***/ (() => {

eval("const canvas = document.querySelector('#canvas');\r\ncanvas.width = 600;\r\ncanvas.height = 400;\r\nconst ctx = canvas.getContext('2d');\r\n\r\nconst cellSize = 50;\r\nlet mouseX = undefined;\r\nlet mouseY = undefined;\r\nconst cells = [];\r\nconst projectiles = [];\r\nconst numOfRows = 7;\r\nlet enemies = [];\r\nlet ressources = 300;\r\n// health of the base. If it falls below 0 the game is lost\r\nlet baseHealth = 500;\r\n\r\nclass Enemy {\r\n  constructor(y) {\r\n    this.health = 100;\r\n    this.worth = 50;\r\n    this.damage = 20;\r\n    this.y = y;\r\n    this.x = canvas.width;\r\n    this.width = cellSize;\r\n    this.height = cellSize;\r\n    this.speed = 0.5;\r\n    this.isMoving = true;\r\n    this.row = y / cellSize;\r\n  }\r\n\r\n  draw() {\r\n    if (this.isMoving) {\r\n      this.x -= this.speed;\r\n    }\r\n\r\n    ctx.fillStyle = '#F00';\r\n    ctx.fillRect(this.x, this.y, cellSize, cellSize);\r\n    // draw health info\r\n    ctx.fillStyle = '#000';\r\n    ctx.font = '16px Arial';\r\n    ctx.fillText(this.health, this.x + 10, this.y + 30);\r\n  }\r\n}\r\n\r\nfunction generateEnemies() {\r\n  // we add cellsize to account for the uppermost part of the\r\n  // canvas that is not part of the gamebord\r\n  let randomRow = Math.floor(Math.random() * numOfRows) * cellSize + cellSize;\r\n  if (frames % 150 === 0) {\r\n    enemies.push(new Enemy(randomRow));\r\n  }\r\n}\r\n\r\nfunction drawEnemies() {\r\n  enemies.forEach(enemy => {\r\n    enemy.draw();\r\n  });\r\n}\r\n\r\nfunction handleEnemies() {\r\n  // if an enemy leaves the board, damage the base and\r\n  // remove him from the enemies array\r\n  for (let i = 0; i < enemies.length; i++) {\r\n    enemies[i].isMoving = true;\r\n    // remove dead enemies and grant ressources\r\n    if (enemies[i].health <= 0) {\r\n      ressources += enemies[i].worth;\r\n      // TODO grant victory points\r\n      enemies.splice(i, 1);\r\n      i--;\r\n      continue;\r\n    }\r\n\r\n    if (enemies[i].x < 0 - cellSize) {\r\n      // damage the base\r\n      baseHealth -= enemies[i].damage;\r\n      // remove enemy from the array\r\n      enemies.splice(i, 1);\r\n      // decrement i because array gets shorter\r\n      // in practice this should be nigh irrelevant because though\r\n      // it prevents \"jumping\" over the next array element, both\r\n      // elements would need to be outside the gameboard on the\r\n      // exact same frame\r\n      i--;\r\n    }\r\n  }\r\n}\r\n\r\nclass Projectile {\r\n  constructor(x, y, damage) {\r\n    this.damage = damage;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = 20;\r\n    this.height = 20;\r\n    this.row = y / cellSize;\r\n    this.speed = 0.5;\r\n  }\r\n\r\n  draw() {\r\n    this.x += this.speed;\r\n    ctx.fillStyle = '#FF0';\r\n    ctx.fillRect(\r\n      this.x + this.width / 2,\r\n      this.y + this.height / 2,\r\n      this.width,\r\n      this.height\r\n    );\r\n  }\r\n}\r\n\r\nclass Defender {\r\n  static cost = 100;\r\n\r\n  constructor(x, y, width, height) {\r\n    this.health = 100;\r\n    this.damage = 20;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.row = y / cellSize;\r\n  }\r\n\r\n  draw() {\r\n    ctx.fillStyle = '#00F';\r\n    ctx.fillRect(this.x, this.y, this.width, this.height);\r\n    // draw health info\r\n    ctx.fillStyle = '#000';\r\n    ctx.font = '16px Arial';\r\n    ctx.fillText(this.health, this.x + 10, this.y + 30);\r\n  }\r\n\r\n  shoot() {\r\n    projectiles.push(new Projectile(this.x, this.y, this.damage));\r\n  }\r\n}\r\n\r\nclass Cell {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = cellSize;\r\n    this.height = cellSize;\r\n    this.defender = null;\r\n    this.row = y / cellSize;\r\n  }\r\n\r\n  isHoverdOver(x, y) {\r\n    return (\r\n      this.x < x &&\r\n      this.x + this.width > x &&\r\n      this.y < y &&\r\n      this.y + this.height > y\r\n    );\r\n  }\r\n}\r\n\r\n// create the cell objects\r\nfunction createCells() {\r\n  for (let x = 0; x < canvas.width; x += cellSize) {\r\n    for (let y = cellSize; y < canvas.height; y += cellSize) {\r\n      let cell = new Cell(x, y);\r\n      cells.push(cell);\r\n    }\r\n  }\r\n}\r\n\r\nfunction highlightMouseCell(e) {\r\n  // only perform this action every 2 frames (primitive debounce).\r\n  if (frames % 2 === 0) {\r\n    // console.log(e);\r\n    // console.log(canvas);\r\n\r\n    // if the mouse is not inside the canvas, return\r\n    if (\r\n      e.clientX - canvas.offsetLeft < 0 || // left\r\n      e.clientX - canvas.offsetLeft > canvas.width || // right\r\n      e.clientY - canvas.offsetTop < 0 || // top\r\n      e.clientY - canvas.offsetTop > canvas.height // bottom\r\n    ) {\r\n      mouseX = undefined;\r\n      mouseY = undefined;\r\n      return;\r\n    }\r\n    mouseX = e.clientX - canvas.offsetLeft;\r\n    mouseY = e.clientY - canvas.offsetTop;\r\n\r\n    // console.log('mouseX: ' + mouseX);\r\n    // console.log('mouseY: ' + mouseY);\r\n  }\r\n}\r\n\r\nfunction drawGrid() {\r\n  ctx.strokeStyle = '#000';\r\n  for (let x = 0; x < canvas.width; x += cellSize) {\r\n    for (let y = cellSize; y < canvas.height; y += cellSize) {\r\n      // highlight the cell with the cursor\r\n      if (\r\n        mouseX &&\r\n        mouseX > x &&\r\n        mouseX < x + cellSize &&\r\n        mouseY &&\r\n        mouseY > y &&\r\n        mouseY < y + cellSize\r\n      ) {\r\n        ctx.strokeStyle = '#0F0';\r\n        ctx.beginPath();\r\n        ctx.rect(x, y, cellSize, cellSize);\r\n        ctx.stroke();\r\n        ctx.strokeStyle = '#000';\r\n      }\r\n      // we can use this later if we want to toggle grid on/off\r\n      else {\r\n        ctx.beginPath();\r\n        ctx.rect(x, y, cellSize, cellSize);\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction drawDefenders() {\r\n  let cellsWithDefenders = cells.filter(cell => cell.defender !== null);\r\n  cellsWithDefenders.forEach(cell => {\r\n    // if defender health is 0 or below, remove him\r\n    if (cell.defender.health <= 0) {\r\n      cell.defender = null;\r\n      return;\r\n    }\r\n    cell.defender.draw();\r\n    if (frames % 150 == 0) cell.defender.shoot();\r\n  });\r\n}\r\n\r\nfunction handleProjectiles() {\r\n  for (let i = 0; i < projectiles.length; i++) {\r\n    projectiles[i].draw();\r\n\r\n    // if the projectile goes off screen, remove it\r\n    if (projectiles[i].x > canvas.width) {\r\n      projectiles.splice(i, 1);\r\n      i--;\r\n      continue;\r\n    }\r\n\r\n    // we use every here, because we cannot break out of forEach once we found a collision\r\n    enemies.every(enemy => {\r\n      if (\r\n        projectiles[i].x + projectiles[i].width >= enemy.x &&\r\n        projectiles[i].row === enemy.row\r\n      ) {\r\n        enemy.health -= projectiles[i].damage;\r\n        projectiles.splice(i, 1);\r\n        i--;\r\n        // return false to break out of every\r\n        return false;\r\n      }\r\n      // return true to keep the loop going\r\n      return true;\r\n    });\r\n  }\r\n}\r\n\r\nfunction placeDefender(e) {\r\n  let activeCellArr = cells.filter(cell => cell.isHoverdOver(mouseX, mouseY));\r\n  if (activeCellArr.length !== 1) return;\r\n\r\n  let activeCell = activeCellArr[0];\r\n\r\n  if (activeCell.defender) {\r\n    console.log('there is already a defender on this tile');\r\n    return;\r\n  }\r\n\r\n  // check if we can afford the defender\r\n  if (ressources - Defender.cost < 0) {\r\n    console.log('not enough ressources');\r\n    return;\r\n  }\r\n\r\n  // make sure that there is no enemy on the tile\r\n  let enemyAtTheGates = enemies.filter(enemy => {\r\n    return detectRowBasedCollision(activeCell, enemy);\r\n  });\r\n  if (enemyAtTheGates.length > 0) {\r\n    console.log('you cannot place defenders on tiles with enemies!');\r\n    return;\r\n  }\r\n\r\n  activeCell.defender = new Defender(\r\n    activeCell.x,\r\n    activeCell.y,\r\n    activeCell.width,\r\n    activeCell.height\r\n  );\r\n  ressources -= Defender.cost;\r\n\r\n  console.log(activeCell);\r\n}\r\n\r\n/** Helper that returns an array of defender objects. */\r\nfunction getDefendersArray() {\r\n  return cells.reduce(function(defendersArr, cell) {\r\n    if (cell.defender !== null) {\r\n      defendersArr.push(cell.defender);\r\n    }\r\n    return defendersArr;\r\n  }, []);\r\n}\r\n\r\n// this function draws all the info about game state\r\nfunction drawGameInfo() {\r\n  ctx.fillStyle = '#000';\r\n  ctx.font = '20px Arial';\r\n  ctx.fillText('Ressources: ' + ressources, 10, 30);\r\n\r\n  ctx.font = '20px Arial';\r\n  ctx.fillText('Health of base: ' + baseHealth, 200, 30);\r\n}\r\n\r\n// handle collision detection between defenders and enemies\r\nfunction detectRowBasedCollision(defender, enemy) {\r\n  return (\r\n    defender.x + defender.width >= enemy.x &&\r\n    // without this condition, it would not be able to place\r\n    // defenders to the right of enemies\r\n    defender.x < enemy.x + enemy.width &&\r\n    defender.row === enemy.row\r\n  );\r\n}\r\n\r\nfunction handleCollisions() {\r\n  let defenders = getDefendersArray();\r\n\r\n  if (defenders.length >= 1) {\r\n    defenders.forEach(defender => {\r\n      enemies.forEach(enemy => {\r\n        if (detectRowBasedCollision(defender, enemy)) {\r\n          // stop the enemy from moving\r\n          enemy.isMoving = false;\r\n          // reduce the health of the defender\r\n          // (debounce it a bit because it is very fast)\r\n          if (frames % 5 === 0) defender.health -= 1;\r\n          // if the defender is dead, start moving again.\r\n          // defenders are removed in drawDefenders function\r\n          if (defender.health <= 0) enemy.isMoving = true;\r\n        }\r\n      });\r\n    });\r\n  } else {\r\n    // if there are no defenders, make sure all enemies are moving\r\n    enemies.forEach(enemy => (enemy.isMoving = true));\r\n  }\r\n}\r\n\r\nlet frames = 0;\r\n\r\nfunction gameLoop() {\r\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n  drawGameInfo();\r\n  drawGrid();\r\n  drawDefenders();\r\n  handleProjectiles();\r\n\r\n  generateEnemies();\r\n  handleEnemies();\r\n  handleCollisions();\r\n  drawEnemies();\r\n\r\n  frames++;\r\n\r\n  requestAnimationFrame(gameLoop);\r\n}\r\n\r\ngameLoop();\r\n// create the cells once.\r\ncreateCells();\r\n\r\ndocument.addEventListener('mousemove', highlightMouseCell);\r\ndocument.addEventListener('click', placeDefender);\r\n\n\n//# sourceURL=webpack://plants_vs_zombies_clone/./src/game.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/game.js"]();
/******/ 	
/******/ })()
;